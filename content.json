{"meta":{"title":"王瑾深","subtitle":"做一个爱折腾的程序员","description":"王瑾深的个人主页,王瑾深,做一个爱折腾的程序员,web王瑾深,王瑾深,程序员王瑾深,王瑾深的博客,商丘王瑾深","author":"王瑾深","url":"git@github.com:wangjinshen/wangjinshen.github.io.git"},"pages":[{"title":"archives","date":"2019-01-16T00:17:08.000Z","updated":"2019-01-16T00:17:10.000Z","comments":true,"path":"archives/index.html","permalink":"git@github.com:wangjinshen/wangjinshen.github.io.git/archives/index.html","excerpt":"","text":""},{"title":"tags","date":"2019-01-29T13:02:44.166Z","updated":"2019-01-16T00:44:56.000Z","comments":false,"path":"tags/index.html","permalink":"git@github.com:wangjinshen/wangjinshen.github.io.git/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"scroll下拉加载+防抖","slug":"scroll下拉加载-防抖","date":"2019-03-27T12:09:05.000Z","updated":"2019-03-27T12:25:58.581Z","comments":true,"path":"2019/03/27/scroll下拉加载-防抖/","link":"","permalink":"git@github.com:wangjinshen/wangjinshen.github.io.git/2019/03/27/scroll下拉加载-防抖/","excerpt":"","text":"scroll下拉加载+防抖代码比较简单123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"&gt; &lt;title&gt;Page Title&lt;/title&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1\"&gt;&lt;/head&gt;&lt;body&gt; &lt;ul&gt; &lt;li&gt;占位符&lt;/li&gt; &lt;li&gt;占位符&lt;/li&gt; &lt;li&gt;占位符&lt;/li&gt; &lt;li&gt;占位符&lt;/li&gt; &lt;li&gt;占位符&lt;/li&gt; &lt;li&gt;占位符&lt;/li&gt; &lt;li&gt;占位符&lt;/li&gt; &lt;li&gt;占位符&lt;/li&gt; &lt;li&gt;占位符&lt;/li&gt; &lt;li&gt;占位符&lt;/li&gt; &lt;li&gt;占位符&lt;/li&gt; &lt;li&gt;占位符&lt;/li&gt; &lt;li&gt;占位符&lt;/li&gt; &lt;li&gt;占位符&lt;/li&gt; &lt;li&gt;占位符&lt;/li&gt; &lt;li&gt;占位符&lt;/li&gt; &lt;li&gt;占位符&lt;/li&gt; &lt;li&gt;占位符&lt;/li&gt; &lt;li&gt;占位符&lt;/li&gt; &lt;li&gt;占位符&lt;/li&gt; &lt;li&gt;占位符&lt;/li&gt; &lt;li&gt;占位符&lt;/li&gt; &lt;li&gt;占位符&lt;/li&gt; &lt;li&gt;占位符&lt;/li&gt; &lt;li&gt;占位符&lt;/li&gt; &lt;li&gt;占位符&lt;/li&gt; &lt;li&gt;占位符&lt;/li&gt; &lt;li&gt;占位符&lt;/li&gt; &lt;li&gt;占位符&lt;/li&gt; &lt;li&gt;占位符&lt;/li&gt; &lt;li&gt;占位符&lt;/li&gt; &lt;li&gt;占位符&lt;/li&gt; &lt;li&gt;占位符&lt;/li&gt; &lt;li&gt;占位符&lt;/li&gt; &lt;li&gt;占位符&lt;/li&gt; &lt;li&gt;占位符&lt;/li&gt; &lt;li&gt;占位符&lt;/li&gt; &lt;li&gt;占位符&lt;/li&gt; &lt;li&gt;占位符&lt;/li&gt; &lt;li&gt;占位符&lt;/li&gt; &lt;li&gt;占位符&lt;/li&gt; &lt;li&gt;占位符&lt;/li&gt; &lt;li&gt;占位符&lt;/li&gt; &lt;li&gt;占位符&lt;/li&gt; &lt;li&gt;占位符&lt;/li&gt; &lt;li&gt;占位符&lt;/li&gt; &lt;li&gt;占位符&lt;/li&gt; &lt;li&gt;占位符&lt;/li&gt; &lt;li&gt;占位符&lt;/li&gt; &lt;li&gt;占位符&lt;/li&gt; &lt;li&gt;占位符&lt;/li&gt; &lt;li&gt;占位符&lt;/li&gt; &lt;li&gt;占位符&lt;/li&gt; &lt;li&gt;占位符&lt;/li&gt; &lt;li&gt;占位符&lt;/li&gt; &lt;li&gt;占位符&lt;/li&gt; &lt;li&gt;占位符&lt;/li&gt; &lt;li&gt;占位符&lt;/li&gt; &lt;li&gt;占位符&lt;/li&gt; &lt;li&gt;占位符&lt;/li&gt; &lt;li&gt;占位符&lt;/li&gt; &lt;li&gt;占位符&lt;/li&gt; &lt;li&gt;占位符&lt;/li&gt; &lt;li&gt;占位符&lt;/li&gt; &lt;li&gt;占位符&lt;/li&gt; &lt;li&gt;占位符&lt;/li&gt; &lt;li&gt;占位符&lt;/li&gt; &lt;li&gt;占位符&lt;/li&gt; &lt;li&gt;占位符&lt;/li&gt; &lt;li&gt;占位符&lt;/li&gt; &lt;li&gt;占位符&lt;/li&gt; &lt;li&gt;占位符&lt;/li&gt; &lt;li&gt;占位符&lt;/li&gt; &lt;li&gt;占位符&lt;/li&gt; &lt;li&gt;占位符&lt;/li&gt; &lt;li&gt;占位符&lt;/li&gt; &lt;li&gt;占位符&lt;/li&gt; &lt;li&gt;占位符&lt;/li&gt; &lt;li&gt;占位符&lt;/li&gt; &lt;li&gt;占位符&lt;/li&gt; &lt;li&gt;占位符&lt;/li&gt; &lt;li&gt;占位符&lt;/li&gt; &lt;li&gt;占位符&lt;/li&gt; &lt;li&gt;占位符&lt;/li&gt; &lt;li&gt;占位符&lt;/li&gt; &lt;li&gt;占位符&lt;/li&gt; &lt;li&gt;占位符&lt;/li&gt; &lt;li&gt;占位符&lt;/li&gt; &lt;li&gt;占位符&lt;/li&gt; &lt;li&gt;占位符&lt;/li&gt; &lt;li&gt;占位符&lt;/li&gt; &lt;li&gt;占位符&lt;/li&gt; &lt;li&gt;占位符&lt;/li&gt; &lt;li&gt;占位符&lt;/li&gt; &lt;li&gt;占位符&lt;/li&gt; &lt;li&gt;占位符&lt;/li&gt; &lt;li&gt;占位符&lt;/li&gt; &lt;li&gt;占位符&lt;/li&gt; &lt;li&gt;占位符&lt;/li&gt; &lt;li&gt;占位符&lt;/li&gt; &lt;/ul&gt; &lt;div class=\"tip\"&gt;&lt;/div&gt; &lt;script&gt; var handle = null var sum = 0 const digital = (func, time) =&gt; &#123; //俩个参数 func函数 time 延迟时间 //返回函数执行次函数 return function (e) &#123; document.querySelector(\".tip\").innerHTML = \"正在加载\" clearTimeout(handle) handle = setTimeout(() =&gt; &#123; //执行func函数指向window 传入参数 func.apply(this, arguments) &#125;, time); &#125; &#125; window.onscroll = digital(function (e) &#123; sum++ //视口高度+scrollY高度 let scrollHei = document.documentElement.clientHeight + window.scrollY //获取document整体高度 let docHeight = document.documentElement.offsetHeight //视口高度+scrollY高度===获取document整体高度 代表到达底部 if (docHeight == scrollHei) &#123; //sum代表加载次数 if (sum &gt; 10) &#123; document.querySelector(\".tip\").innerHTML = \"没有更多了\" return false &#125; for (let i = 0; i &lt; 10; i++) &#123; var para = document.createElement(\"p\"); para.innerHTML = \"这是新段落。\" document.getElementsByTagName(\"ul\")[0].appendChild(para) &#125; &#125; &#125;, 5000) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;","categories":[],"tags":[{"name":"scroll下拉加载+防抖","slug":"scroll下拉加载-防抖","permalink":"git@github.com:wangjinshen/wangjinshen.github.io.git/tags/scroll下拉加载-防抖/"}]},{"title":"日期对象Date","slug":"时间对象Date","date":"2019-03-27T01:17:42.000Z","updated":"2019-03-27T02:02:02.636Z","comments":true,"path":"2019/03/27/时间对象Date/","link":"","permalink":"git@github.com:wangjinshen/wangjinshen.github.io.git/2019/03/27/时间对象Date/","excerpt":"","text":"js 日期对象一个简陋的倒计时1234567891011121314151617181920212223242526272829303132333435363738394041424344454647function result(nian) &#123; //当前时间 var date = new Date() var Ntime = date.getTime() //未来时间 var Ddate = new Date(nian) var Dtime = Ddate.getTime() //时间差 var newDate = Dtime - Ntime if(Dtime&lt;Ntime)&#123; return &#123; mag:\"请输入未来时间\" &#125; &#125; //算法 var yearLevelValue = 365 * 24 * 60 * 60 * 1000; var monthLevelValue = 30 * 24 * 60 * 60 * 1000; var dayLevelValue = 24 * 60 * 60 * 1000; var hourLevelValue = 60 * 60 * 1000; var minuteLevelValue = 60 * 1000; // 年 var Ogetyear = Math.floor(newDate / yearLevelValue) //月 var Ogetmonth = Math.floor(newDate % yearLevelValue / monthLevelValue) //日 var Ogetday = Math.floor(newDate % yearLevelValue % monthLevelValue / dayLevelValue) //时 var Ogethour = Math.floor(newDate % yearLevelValue % monthLevelValue % dayLevelValue / hourLevelValue) //分 var Ogetminu = Math.floor(newDate % yearLevelValue % monthLevelValue % dayLevelValue % hourLevelValue / minuteLevelValue) //秒 var Ogetmiao = Math.floor(newDate % yearLevelValue % monthLevelValue % dayLevelValue % hourLevelValue % minuteLevelValue / 1000) return &#123; Ogetyear, Ogetmonth, Ogetday, Ogethour, Ogetminu, Ogetmiao &#125;&#125;setInterval(function () &#123; const obj = result(\"2019,4,1\") console.log(`还有$&#123;obj.Ogetday&#125;天$&#123;obj.Ogethour&#125;小时$&#123;obj.Ogetminu&#125;分$&#123;obj.Ogetmiao&#125;秒`)&#125;, 1000) Date 对象的一些方法获取日期对象中的日期var date = new Date()将日期对象转换为字符串可以使用以下4种方法： date.toString();//将日期对象转换为字符串时，采用的是本地时间 date.toLocalString();//将日期对象转换为字符串，采用的是本地时间，显示的是地方日期的格式 date.toUTCString();//将日期对象转换为字符串时，采用的是世界时间。 date.toGMTString();//将日期对象转换为字符串时，采用的是GMT时间，但是已被禁止使用，一般用toUTCString()方 date.getYear();//获取年份，但不建议使用。 date.getFullYear();//获取年份，，以四位数显式，建议使用 date.getMonth();//获取月份，值为0-11，一月份为0，二月份为1… date.getDate();//获取天数，即一个月中的某一天 date.getDay();//获取一周中的第几天，值为0-6，周日为0… date.getHours();//返回小时部分 date.getMinutes();//返回分钟部分 date.getSeconds();//返回秒钟部分 date.getMilliseconds();//返回毫秒部分 date.getTime();//返回日期对象中的时间与1970年1月1日0时0分0秒所间隔的毫秒数 设置日期对象中的日期 date.setYear(year);//不建议使用 date.setFullYear(year,month,day);//year四位数;month：0-11，该参数可省略;day：1-31， 该参数可省略 date.setMonth(month,day);//month：0-11;day：1-31， 该参数可省略 date.getDate(day);//day：1-31","categories":[],"tags":[{"name":"js","slug":"js","permalink":"git@github.com:wangjinshen/wangjinshen.github.io.git/tags/js/"},{"name":"日期对象","slug":"日期对象","permalink":"git@github.com:wangjinshen/wangjinshen.github.io.git/tags/日期对象/"}]},{"title":"利用对象计算字符串出现次数","slug":"利用对象计算字符串出现次数","date":"2019-03-26T07:50:58.000Z","updated":"2019-03-26T07:53:25.400Z","comments":true,"path":"2019/03/26/利用对象计算字符串出现次数/","link":"","permalink":"git@github.com:wangjinshen/wangjinshen.github.io.git/2019/03/26/利用对象计算字符串出现次数/","excerpt":"","text":"利用对象计算字符串出现次数比较简单直接上代码12345678910111213141516171819var str = 'sdfssaaasasasaasaa';var obj =&#123;&#125;for (let i = 0; i &lt; str.length; i++) &#123; if(obj.hasOwnProperty(str[i]))&#123; let sum = str[i] obj[sum]+=1 &#125;else&#123; let sum = str[i] obj[sum]=1 &#125;&#125;var objSum = Object.values(obj)for (const key in obj) &#123; if (obj.hasOwnProperty(key)) &#123; if(obj[key]===Math.max(...objSum))&#123; console.log(key, obj[key]) &#125; &#125;&#125;","categories":[],"tags":[{"name":"js","slug":"js","permalink":"git@github.com:wangjinshen/wangjinshen.github.io.git/tags/js/"}]},{"title":"Generator","slug":"Generator","date":"2019-03-21T11:15:08.000Z","updated":"2019-03-22T02:22:52.133Z","comments":true,"path":"2019/03/21/Generator/","link":"","permalink":"git@github.com:wangjinshen/wangjinshen.github.io.git/2019/03/21/Generator/","excerpt":"","text":"Generator函数基本概念Generator 函数是 ES6 提供的一种异步编程解决方案，语法上，首先可以把它理解成，Generator 函数是一个状态机，封装了多个内部状态。 执行 Generator 函数会返回一个遍历器对象，也就是说，Generator 函数除了状态机，还是一个遍历器对象生成函数。返回的遍历器对象，可以依次遍历 Generator 函数内部的每一个状态。 形式上，Generator 函数是一个普通函数，但是有两个特征。一是，function关键字与函数名之间有一个星号；二是，函数体内部使用yield表达式，定义不同的内部状态（yield在英语里的意思就是“产出”）。 例如：12345678910function* fn()&#123; yield \"第一次调用\"; yield \"第二次调用\"; return \"第三次\"&#125;var fn1 = fn()console.log(fn1.next(), '') //&#123; value: '第一次调用', done: false &#125; ''console.log(fn1.next(), '') //&#123; value: '第二次调用', done: false &#125; ''console.log(fn1.next(), '') //&#123; value: '第三次', done: true &#125; ''console.log(fn1.next(), '') //&#123; value: undefined, done: true &#125; '' 第一次调用，Generator 函数开始执行，直到遇到第一个yield表达式为止。next方法返回一个对象，它的value属性就是当前yield表达式的值第一次调用，done属性的值false，表示遍历还没有结束。 第二次调用，Generator 函数从上次yield表达式停下的地方，一直执行到下一个yield表达式。next方法返回的对象的value属性就是当前yield表达式的值第二次调用，done属性的值false，表示遍历还没有结束。 第三次调用，Generator 函数从上次yield表达式停下的地方，一直执行到return语句（如果没有return语句，就执行到函数结束）。next方法返回的对象的value属性，就是紧跟在return语句后面的表达式的值（如果没有return语句，则value属性的值为undefined），done属性的值true，表示遍历已经结束。 第四次调用，此时 Generator 函数已经运行完毕，next方法返回对象的value属性为undefined，done属性为true。以后再调用next方法，返回的都是这个值。 我们在试一下没有return结果会怎样12345678910function* fn()&#123; yield \"第一次调用\"; yield \"第二次调用\"; // return \"第三次\"&#125;var fn1 = fn()console.log(fn1.next(), '') //&#123; value: '第一次调用', done: false &#125; ''console.log(fn1.next(), '') //&#123; value: '第二次调用', done: false &#125; ''console.log(fn1.next(), '') //&#123; value: undefined, done: true &#125; ''console.log(fn1.next(), '') //&#123; value: undefined, done: true &#125; '' 区别 当调用Generator函数中有return值的时候 通过next执行到return是返回的时会返回 return的值并且done返回true表示已经执行结束， 当调用Generator函数中有return值的时候 通过next执行到最后一个值的时候 done并不会返回true,因为它并不知到当前值为最后一个值，再次调用他会返回一个undefined done返回true表示已经执行结束，但是如果我们通过 done返回作为判断条件的话 有return 会及时停止返回 假设我们想要获取最后一个值代码如下： 123456789101112131415function* fn() &#123; yield \"第一次调用\"; yield \"第二次调用\"; return \"第三次\"&#125;var fn1 = fn()function getNext() &#123; var val= fn1.next() if (val.done) &#123; console.log(val)//&#123; value: '第三次', done: true &#125; '' return &#125; getNext()&#125;getNext() 没有return123456789101112131415function* fn() &#123; yield \"第一次调用\"; yield \"第二次调用\"; // return \"第三次\"&#125;var fn1 = fn()function getNext() &#123; var val= fn1.next() if (val.done) &#123; console.log(val)//&#123; value: undefined, done: true &#125; '' return &#125; getNext()&#125;getNext() 总结调用Generator 函数，会返回一个遍历对象，代表 Generator 函数的内部指针,以后，每次调用对象的next方法，就会返回一个带有value和done两个属性的对象。value表示当前内部状态的值，也就是yield后面的表达式例如：yield &quot;第一次调用&quot;;返回yield后面的值;done的属性返回的是一个布尔值，表示便利是否结束 yield表达式由于 Generator 函数返回的遍历器对象，只有调用next方法才会遍历下一个内部状态，所以其实提供了一种可以暂停执行的函数。yield表达式就是暂停标志。 需要注意的是，yield表达式后面的表达式，只有当调用next方法、内部指针指向该语句时才会执行，因此等于为 JavaScript 提供了手动的“惰性求值”（Lazy Evaluation）的语法功能。 也就是说只有通过手动的next的调用才会去执行返回值 没有next方法调用的话的话就不会被触发 Generator 函数可以不用yield表达式，这时就变成了一个单纯的暂缓执行函数123456789function* f() &#123; console.log('执行了！') &#125; var generator = f(); setTimeout(function () &#123; generator.next() &#125;, 2000); 与 Iterator 接口的关系任意一个对象的Symbol.iterator方法，等于该对象的遍历器生成函数，调用该函数会返回该对象的一个遍历器对象。 由于 Generator 函数就是遍历器生成函数，因此可以把 Generator 赋值给对象的Symbol.iterator属性，从而使得该对象具有 Iterator 接口。12345678910111213var myIterable = &#123;&#125;;myIterable[Symbol.iterator] = function* () &#123; yield 1; yield 2; yield 3;&#125;;for (const iterator of myIterable) &#123; console.log(iterator)&#125;// 1// 2// 3 上面代码中，Generator 函数赋值给Symbol.iterator属性，从而使得myIterable对象具有了 Iterator 接口，可以被遍历了。 next 方法的参数yield表达式本身没有返回值，或者说总是返回undefined。next方法可以带一个参数，该参数就会被当作上一个yield表达式的返回值。123456789function* fn(x) &#123;var a = yield (x+8)var b = yield (a/2)return (x + a + b);&#125;var fn1 = fn(8)console.log(fn1.next(), '')// &#123; value: 16, done: false &#125; ''console.log(fn1.next(8), '')// &#123; value: 4, done: false &#125; ''console.log(fn1.next(8), '')// &#123; value: 24, done: true &#125; ' 异步任务的封装1234567891011121314//引入模块var fetch = require('node-fetch');function* gen()&#123; var url = 'https://api.github.com/users/github'; var result = yield fetch(url); yield result.bio&#125;var g = gen();var result = g.next();result.value.then(function(data)&#123; return data.json();&#125;).then(function(data)&#123; g.next(data);&#125;);","categories":[],"tags":[{"name":"es6","slug":"es6","permalink":"git@github.com:wangjinshen/wangjinshen.github.io.git/tags/es6/"},{"name":"异步","slug":"异步","permalink":"git@github.com:wangjinshen/wangjinshen.github.io.git/tags/异步/"}]},{"title":"如何监听一个对象的变化","slug":"如何监听一个对象的变化","date":"2019-02-24T11:25:04.000Z","updated":"2019-02-24T11:26:44.258Z","comments":true,"path":"2019/02/24/如何监听一个对象的变化/","link":"","permalink":"git@github.com:wangjinshen/wangjinshen.github.io.git/2019/02/24/如何监听一个对象的变化/","excerpt":"","text":"如何监听一个对象的变化12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;script&gt; let data = &#123; user: &#123; name: \"liangshaofeng\", age: \"24\" &#125;, address: &#123; city: \"beijing\" &#125; &#125;; class Observer &#123; constructor(props) &#123; this.data = props this.walk(data) // return data &#125; //递归 walk(obj) &#123; let val; for (const key in obj) &#123; if (obj.hasOwnProperty(key)) &#123; val = obj[key] if (String.prototype.slice.call(val) == \"[object Object]\") &#123; this.walk(val) &#125; this.convert(key, val) &#125; &#125; &#125; convert(key, val) &#123; Object.defineProperty(this.data, key, &#123; enumerable: true, configurable: true, get() &#123; console.log('你访问了' + key) return val &#125;, set(newVal) &#123; console.log(\"你改变了\" + key) console.log(\"你改变了新值\" + newVal) if (newVal === val) return; val = newVal &#125; &#125;) &#125; &#125; new Observer(data) console.log(data) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 参考地址：https://github.com/youngwind/blog/issues/84","categories":[],"tags":[{"name":"vue","slug":"vue","permalink":"git@github.com:wangjinshen/wangjinshen.github.io.git/tags/vue/"},{"name":"学习","slug":"学习","permalink":"git@github.com:wangjinshen/wangjinshen.github.io.git/tags/学习/"}]},{"title":"浅谈Object.defineProperty","slug":"浅谈Object-defineProperty","date":"2019-02-22T12:31:33.000Z","updated":"2019-02-22T14:35:23.435Z","comments":true,"path":"2019/02/22/浅谈Object-defineProperty/","link":"","permalink":"git@github.com:wangjinshen/wangjinshen.github.io.git/2019/02/22/浅谈Object-defineProperty/","excerpt":"","text":"浅谈Object.defineProperty参数 obj：必需。目标对象 prop：必需。需定义或修改的属性的名字 descriptor：必需。目标属性所拥有的特性 descriptor中的参数 Configurable:表示能否通过delete删除属性从而重新定义属性； Enumerable：表示能否通过for-in循环返回属性 writable：表示能否修改属性的值 Value：包含这个属性的数据值 get：读取属性值执行的内置函数 set：更改属性值执行的内置函数更改后的参数会在形参中Configurable 123456var obj = &#123;a:1&#125; Object.defineProperty(obj,\"a\",&#123; configurable:true &#125;) delete obj.a console.log(obj)//&#123;&#125; 123456var obj = &#123;a:1&#125; Object.defineProperty(obj,\"a\",&#123; configurable:false &#125;) delete obj.a console.log(obj)//&#123;a:1&#125; 12345678910111213141516171819202122232425262728293031323334var obj = &#123;&#125;//第一种情况：configurable设置为false，不能再次修改特性。Object.defineProperty(obj,\"a\",&#123; value:\"hello\", writable:false, enumerable:false, configurable:false&#125;);//重新修改特性Object.defineProperty(obj,\"a\",&#123; value:\"hello\", writable:true, enumerable:true, configurable:true&#125;);console.log( obj.a ); //报错：Uncaught TypeError: Cannot redefine property: a//第二种情况：configurable设置为true，可以再次修改特性。Object.defineProperty(obj,\"a\",&#123; value:\"hello\", writable:false, enumerable:false, configurable:true&#125;);//重新修改特性Object.defineProperty(obj,\"a\",&#123; value:\"hello\", writable:true, enumerable:true, configurable:true&#125;);console.log( obj.a ); //hello Enumerable12345678910var obj = &#123;a:1,b:2&#125; Object.defineProperty(obj,\"a\",&#123; enumerable:true &#125;) for (const key in obj) &#123; if (obj.hasOwnProperty(key)) &#123; const element = obj[key]; console.log(key) // a b &#125; &#125; 12345678910var obj = &#123;a:1,b:2&#125; Object.defineProperty(obj,\"a\",&#123; enumerable:false &#125;) for (const key in obj) &#123; if (obj.hasOwnProperty(key)) &#123; const element = obj[key]; console.log(key) // b &#125; &#125; writable123456var obj = &#123;a:1&#125; Object.defineProperty(obj,\"a\",&#123; writable:false &#125;) obj.a=3 console.log(obj)//&#123;a:1&#125; 存取器描述当使用存取器描述属性的特性的时候，允许设置以下特性属性：1234567var obj = &#123;&#125;;Object.defineProperty(obj,\"a\",&#123; get:function ()&#123;&#125; | undefined, set:function (value)&#123;&#125; | undefined configurable: true | false enumerable: true | false&#125;); 注意：当使用了getter或setter方法，不允许使用writable和value这两个属性 12345678910111213141516171819var obj = &#123;&#125;;var initValue = 'hello';Object.defineProperty(obj,\"a\",&#123; get:function ()&#123; //当获取值的时候触发的函数 return initValue; &#125;, set:function (value)&#123; //当设置值的时候触发的函数,设置的新值通过参数value拿到 initValue = value; &#125;&#125;);//获取值console.log( obj.a ); //hello//设置值obj.a = 'change value';console.log( obj.a ); //change value 注意：get或set不是必须成对出现，任写其一就可以。如果不设置方法，则get和set的默认值为undefined 参考：https://segmentfault.com/a/1190000007434923","categories":[],"tags":[{"name":"js","slug":"js","permalink":"git@github.com:wangjinshen/wangjinshen.github.io.git/tags/js/"},{"name":"defineProperty","slug":"defineProperty","permalink":"git@github.com:wangjinshen/wangjinshen.github.io.git/tags/defineProperty/"}]},{"title":"vue组件递归实现左侧菜单导航树","slug":"vue组件递归实现左侧菜单导航树","date":"2019-02-14T03:55:18.000Z","updated":"2019-02-14T07:20:53.097Z","comments":true,"path":"2019/02/14/vue组件递归实现左侧菜单导航树/","link":"","permalink":"git@github.com:wangjinshen/wangjinshen.github.io.git/2019/02/14/vue组件递归实现左侧菜单导航树/","excerpt":"","text":"vue组件递归实现左侧菜单导航树这里使用的是 vue-cli 的webpack打包工具首先准备好我们符合递归条件的数据./build/mack/data.json 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576[ &#123; \"id\": 1, \"name\": \"第一层\", \"children\": [ &#123; \"name\": \"第二层\" &#125;, &#123; \"name\": \"第二层\" &#125;, &#123; \"name\": \"第二层\" &#125; ] &#125;, &#123; \"id\": 1, \"name\": \"第一层\", \"children\": [ &#123; \"name\": \"第二层\" &#125;, &#123; \"name\": \"第二层\", \"children\": [ &#123; \"name\": \"第三层\" &#125;, &#123; \"name\": \"第三层\" &#125;, &#123; \"name\": \"第三层\" &#125; ] &#125;, &#123; \"name\": \"第二层\", \"children\": [ &#123; \"name\": \"第三层\" &#125;, &#123; \"name\": \"第三层\" &#125;, &#123; \"name\": \"第三层\", \"children\": [ &#123; \"name\": \"第四层\" &#125;, &#123; \"name\": \"第四层\" &#125;, &#123; \"name\": \"第四层\", \"children\": [ &#123; \"name\": \"第五层\" &#125;, &#123; \"name\": \"第五层\" &#125;, &#123; \"name\": \"第五层\" &#125; ] &#125; ] &#125; ] &#125; ] &#125;] 创建接口./webpack.dev.conf.js 1234devServer: &#123; ... before: require('./mock/index') &#125;, ./mock/index 123456const data = require('./data')module.exports = function (app) &#123; app.get('/data', (require, result) =&gt; &#123; result.send(data) &#125;)&#125; 简单封装 fetch工具./src/api.js123456export async function request (url) &#123; return fetch(url).then(res =&gt; &#123; return res.json() &#125;).then(data =&gt; data)&#125; 封装组建 ./src/components/accordion.vue 123456789101112131415161718192021222324252627282930313233343536373839404142&lt;template&gt; &lt;div class=\"show\"&gt; &lt;ul v-for=\"(item,index) in data\" :key=\"index\"&gt; &lt;li @click=\"showhd(index,$event)\" :class=\"[item.children?'color':'']\"&gt;&#123;&#123;item.name&#125;&#125;&lt;/li&gt; &lt;Accordion v-if=\"item.children\" :data=\"item.children\"&gt;&lt;/Accordion&gt; &lt;/ul&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: 'Accordion', props: ['data'], methods: &#123; showhd (id, e) &#123; const dom = e.target.nextElementSibling if (dom.className === 'show') &#123; dom.className = 'head' &#125; else &#123; dom.className = 'show' &#125; &#125; &#125;&#125;&lt;/script&gt;&lt;style scoped&gt; .ul &#123; overflow: hidden; &#125; .head &#123; display: none; &#125; .show &#123; display: block; &#125; .color&#123; color: brown; &#125;&lt;/style&gt; 调用组建 ./src/components/HelloWorld.vue 12345678910111213141516171819202122232425262728&lt;template&gt; &lt;div id=\"app\"&gt; &lt;Accordion :data=\"this.data\"&gt;&lt;/Accordion&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import &#123;request&#125; from '../api/index'import Accordion from './accordion'export default &#123; components: &#123;Accordion&#125;, data () &#123; return &#123; data: &#123;&#125; &#125; &#125;, mounted () &#123; request('/data').then(res =&gt; &#123; this.data = res &#125;) &#125;&#125;&lt;/script&gt;&lt;style&gt;&lt;/style&gt; 项目地址：https://github.com/wangjinshen/vue.git","categories":[],"tags":[{"name":"vue","slug":"vue","permalink":"git@github.com:wangjinshen/wangjinshen.github.io.git/tags/vue/"},{"name":"递归","slug":"递归","permalink":"git@github.com:wangjinshen/wangjinshen.github.io.git/tags/递归/"}]},{"title":"跨域","slug":"跨域","date":"2019-02-14T00:45:33.000Z","updated":"2019-02-14T02:11:22.829Z","comments":true,"path":"2019/02/14/跨域/","link":"","permalink":"git@github.com:wangjinshen/wangjinshen.github.io.git/2019/02/14/跨域/","excerpt":"","text":"跨域什么是跨域为什么要跨域 ？浏览器对于JavaScript的同源策略的限制，例如a.cn不能调用b.js的数据。也是属于对网站的一种保护机制 同源策略:是指 相同域名 相同端口 相同协议 跨域的三种方式cls 服务端跨域 一我们先模拟出不符合同源策略的生产环境 服务端代码 在这里是在这里是通过gulp起了一个8080的端口12345678910111213141516const gulp = require('gulp')const webserver = require('gulp-webserver')gulp.task(\"server\", () =&gt; &#123; gulp.src('./') .pipe(webserver(&#123; host: \"localhost\", port: 8080, middleware(req, res) &#123; const data = &#123; name: \"neinei\", age: 19 &#125; res.writeHead(200, &#123; 'Content-Type': 'application/json;charset=utf-8', &#125;) res.end(JSON.stringify(data)) &#125; &#125;))&#125;) 客户端js代码通过gulp起了一个人端口8000的端口然后把html页面返回到浏览器1234567891011121314let fs = require(\"fs\")const gulp = require(\"gulp\")const webserver = require(\"gulp-webserver\")let result = fs.readFileSync(\"./index.html\", \"utf-8\")gulp.task(\"api\", () =&gt; &#123; gulp.src('./') .pipe(webserver(&#123; host: \"localhost\", port: 8000, middleware(req, res) &#123; res.end(result) &#125; &#125;))&#125;) 客户端html展示页面代码12345678910111213141516171819202122232425262728293031&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt; this is page&lt;script&gt;function request(url) &#123; return new Promise((resolve, reject) =&gt; &#123; let xml = new XMLHttpRequest() xml.open(\"GET\", url, false) xml.onreadystatechange = function () &#123; if(xml.readyState!=4)return false if(xml.status===200)&#123; resolve(xml.responseText) &#125; &#125; xml.send() &#125;)&#125;request('http://localhost:8080').then(res=&gt;&#123; console.log(res)&#125;).catch(err=&gt;&#123; console.log(err)&#125;)&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 在这里起了两个服务一个端口为8080一个端口为8000满足了跨域的需求发起ajax试一下 结果 添加语法 &#39;Access-Control-Allow-Origin&#39;: &#39;*&#39;服务端代码123456789101112131415161718 const gulp = require('gulp')const webserver = require('gulp-webserver')gulp.task(\"server\", () =&gt; &#123; gulp.src('./') .pipe(webserver(&#123; host: \"localhost\", port: 8080, middleware(req, res) &#123; const data = &#123; name: \"neinei\", age: 19 &#125; res.writeHead(200, &#123; 'Content-Type': 'application/json;charset=utf-8', 'Access-Control-Allow-Credentials': true, 'Access-Control-Allow-Origin': '*' &#125;) res.end(JSON.stringify(data)) &#125; &#125;))&#125;) 结果 Access-Control-Allow-Origin1Access-Control-Allow-Origin 响应头指定了该响应的资源是否被允许与给定的origin共享 *对于不需具备凭证（credentials）的请求，服务器会以“*”作为通配符，从而允许所有域都具有访问资源的权限。 &lt;origin&gt;指定一个可以访问资源的URI。 jsonp跨域 二jsonp的原理通过html中带有src属性的标签发起请求 src:因为src不受同源策略影响 一般使用&lt;script&gt;标签 在请求路由中带去一个回调函数， 在服务端返回执行。 就可以在函数中的形参中拿到数据 服务端代码 端口号 88881234567891011121314var http = require('http');var url = require('url')var data = JSON.stringify(&#123; name: \"heihei\", age: 21 &#125;)http.createServer(function (request, response) &#123; var parse = url.parse(request.url, true) response.writeHead(200, &#123; 'Content-Type': 'text/plain' &#125;); if (parse.query.callback) &#123; response.end(parse.query.callback+\"(\"+data+\")\") return &#125; response.end(data);&#125;).listen(8888, () =&gt; &#123; console.log(8888)&#125;); 客户端代码 端口80001234567891011121314let fs = require(\"fs\")const gulp = require(\"gulp\")const webserver = require(\"gulp-webserver\")let result = fs.readFileSync(\"./index.html\", \"utf-8\")gulp.task(\"api\", () =&gt; &#123; gulp.src('./') .pipe(webserver(&#123; host: \"localhost\", port: 8000, middleware(req, res) &#123; res.end(result) &#125; &#125;))&#125;) 客户端html代码12345678910111213141516171819202122&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt; this is page &lt;script&gt; function cb(data) &#123; console.log(data) &#125; var script = document.createElement('script') script.setAttribute('src', \"http://localhost:8888?callback=cb\") document.body.appendChild(script) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 客户端 动态创建一个script标签 创建一个函数来接受来接收数据 如上代码 我们创建了一个cb函数 设置src属性为我们的接口地址 http://localhost:8888?callback=cb 通过appendChild方法吧script插入body插入后会自动发起请求 服务端 解析客户端传来的参数，通过node模块中的url模块来解析 url.parse：解析前端的请求参数 第二个参数为true时会把参数解析成对象 parse.query：会把参数解析放在parse.query的对象中12var parse = url.parse(request.url, true) 判断是否传来callback函数然后通过end返回 1234if (parse.query.callback) &#123; response.end(parse.query.callback+\"(\"+data+\")\") return &#125; 服务端的函数接收数据 123function cb(data) &#123; console.log(data) &#125; 降域 三域名为http://b.com/b的网页以iframe的形式嵌在域名为http://a.com/a的网页中，它们来自不同的域名，正常情况下不能进行跨域访问。 但是当我们为两个页面都加上这样一句代码： document.domain = ‘wuxiaozhou.com’; 这时候这两个页面就位于同一个域名下面了，就可以在页面a中对页面b进行操作了，两个页面可以互相访问。 项目地址: https://github.com/wangjinshen/cross-domain.git","categories":[],"tags":[{"name":"跨域","slug":"跨域","permalink":"git@github.com:wangjinshen/wangjinshen.github.io.git/tags/跨域/"}]},{"title":"vue-cli支持Typescript","slug":"vue-cli支持Typescript","date":"2019-02-07T04:10:47.000Z","updated":"2019-02-07T04:18:18.975Z","comments":true,"path":"2019/02/07/vue-cli支持Typescript/","link":"","permalink":"git@github.com:wangjinshen/wangjinshen.github.io.git/2019/02/07/vue-cli支持Typescript/","excerpt":"","text":"vue-cli支持Typescript安装typescript及loader1npm install typescript ts-loader --save-dev 修改rules123456789101112131415&#123; test: /\\.tsx$/, exclude: /node_modules/, enforce: 'pre', loader: 'tslint-loader', &#125;, &#123; test: /\\.tsx?$/, loader: 'ts-loader', exclude: /node_modules/, options: &#123; appendTsSuffixTo: [/\\.vue$/], &#125; &#125;, 声明vue模块为每个文件声明全局模块.vue，这样每个单文件组件就可以被自动被声明了。在src目录下新建文件 typings/vue.d.ts：1234declare module '*.vue' &#123; import Vue from 'vue' export default Vue&#125; 新建tsconfig.json位置 根目录 12345678910111213141516171819202122232425&#123; \"compilerOptions\": &#123; \"jsx\": \"preserve\", \"lib\": [ \"dom\", \"es5\", \"es2015\", \"es2015.promise\" ], \"allowJs\": false, \"module\": \"es2015\", \"moduleResolution\": \"node\", \"target\": \"es5\", \"sourceMap\": true, \"emitDecoratorMetadata\": true, \"experimentalDecorators\": true, \"allowSyntheticDefaultImports\": true, \"isolatedModules\": false, \"declaration\": false, \"noImplicitAny\": true, \"removeComments\": true, \"strictNullChecks\": true, &#125;, \"compileOnSave\": false&#125; 将js改为ts将.js后缀改为.ts.vue单文件组间中 script lang =’ts’修改入口文件 123entry: &#123; app: './src/main.ts' &#125;,","categories":[],"tags":[{"name":"ts","slug":"ts","permalink":"git@github.com:wangjinshen/wangjinshen.github.io.git/tags/ts/"},{"name":"vue","slug":"vue","permalink":"git@github.com:wangjinshen/wangjinshen.github.io.git/tags/vue/"}]},{"title":"Hello World","slug":"hello-world","date":"2019-01-29T13:02:44.197Z","updated":"2019-01-16T06:47:54.000Z","comments":true,"path":"2019/01/29/hello-world/","link":"","permalink":"git@github.com:wangjinshen/wangjinshen.github.io.git/2019/01/29/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[{"name":"bolg","slug":"bolg","permalink":"git@github.com:wangjinshen/wangjinshen.github.io.git/tags/bolg/"}]},{"title":"vue 的一些扩展方法","slug":"vue的一些扩展方法","date":"2019-01-28T12:21:10.000Z","updated":"2019-01-29T00:46:50.000Z","comments":true,"path":"2019/01/28/vue的一些扩展方法/","link":"","permalink":"git@github.com:wangjinshen/wangjinshen.github.io.git/2019/01/28/vue的一些扩展方法/","excerpt":"","text":"vue 的一些扩展的方法扩展全局组建12345678const components=&#123; component1, component2, component3&#125;for(let key in components)&#123; Vue.component(key,components[key])&#125; 扩展全局指令1234567891011Vue.directive(\"option\", &#123; inserted(dom, binding) &#123; dom.addEventListener(\"click\", (e) =&gt; &#123; const node = e.target const x = e.pageX const y = e.pageY console.log(node, x, y) &#125;) console.log(dom, binding) &#125;&#125;) 扩展 veu 类的方法123Vue.method=function()&#123; console.log(\"扩展了类的方法\")&#125; 扩展 vue 原型，在 vue 组件中就可以通过 this 访问调用123Vue.proptype.$api= function1()&#123; console.log(\"调用api\") &#125;","categories":[],"tags":[{"name":"vue","slug":"vue","permalink":"git@github.com:wangjinshen/wangjinshen.github.io.git/tags/vue/"}]},{"title":"Vuex 的 Holle world","slug":"vuex","date":"2019-01-28T03:48:50.000Z","updated":"2019-01-28T05:59:50.000Z","comments":true,"path":"2019/01/28/vuex/","link":"","permalink":"git@github.com:wangjinshen/wangjinshen.github.io.git/2019/01/28/vuex/","excerpt":"","text":"Vuex 的 Holle world安装1npm install Vuex --save-dev 创建仓库123456789101112131415161718//引入包import Vue from 'vue';import Vuex from \"vuex\"Vue.use(Vuex)//挂载到全局const store = new Vuex.Store(&#123; //全局状态 state: &#123; count: 0 &#125;, //改变仓库的方法集合 mutations: &#123; //改变仓库的方法 plas(state) &#123; state.count++ &#125; &#125;&#125;)export default store; 入口文件 1234567//挂载到vuenew Vue(&#123; el: \"#app\", render: h =&gt; h(App), router, store,&#125;) 使用1234567891011121314151617181920212223242526&lt;template&gt; &lt;div&gt; &lt;button @click=\"plas\" type=\"button\"&gt;+&lt;/button&gt; &#123;&#123;count&#125;&#125; &lt;button type=\"button\"&gt;-&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; computed: &#123; count() &#123; return this.$store.state.count; &#125; &#125;, methods: &#123; plas()&#123; //通过commit方法执行plas函数 this.$store.commit(\"plas\") &#125; &#125;,&#125;;&lt;/script&gt;&lt;style scoped lang=\"\"&gt;&lt;/style&gt;","categories":[],"tags":[{"name":"vue","slug":"vue","permalink":"git@github.com:wangjinshen/wangjinshen.github.io.git/tags/vue/"},{"name":"vuex","slug":"vuex","permalink":"git@github.com:wangjinshen/wangjinshen.github.io.git/tags/vuex/"}]},{"title":"http-equiv","slug":"http-equiv","date":"2019-01-26T03:08:12.000Z","updated":"2019-01-26T03:17:48.000Z","comments":true,"path":"2019/01/26/http-equiv/","link":"","permalink":"git@github.com:wangjinshen/wangjinshen.github.io.git/2019/01/26/http-equiv/","excerpt":"","text":"概念：相当于 http 的文件头作用，它可以向浏览器传回一些有用的信息，以帮助正确和精确地显示网页内容，与之对应的属性值为 content, content 中的内容其实就是各个参数的变量值。 语法：1&lt;metahttp-equiv=\"参数\"content=\"参数变量值\"&gt; 参数： x-UA-Compatible说明：指定网页兼容性代码： 1&lt;meta http-equiv=\"Pragma\" content=\"no-cache\"&gt; Praqma:说明：是用于设定禁止浏览器从本地机的缓存中调阅页面内容，设定后一旦离开网页就无法从 Cache 中再调出代码： 1&lt;meta http-equiv=\"Pragma\" content=\"no-cache\"&gt; Window-target说明：强制页面在当前窗口以独立页面显示。代码： 1&lt;meta http-equiv=\"Window-target\" content=\"top\"&gt; Keywords:说明：搜索引擎关键字。代码： 1&lt;meta http-equiv=\"keywords\" content=\"keyword1, keyword2, keyword3\"&gt; cache-control说明：清除缓存。代码： 1&lt;meta http-equiv=\"cache-control\" content=\"no-cache\"&gt; description说明：强制页面在当前窗口以独立页面显示。代码： 1&lt;meta http-equiv=\"description\" content=\"This is my websit\"&gt; Window-target:说明：强制页面在当前窗口以独立页面显示。代码： 1&lt;meta http-equiv=\"Window-target\" content=\"top\"&gt;","categories":[],"tags":[{"name":"http-equiv","slug":"http-equiv","permalink":"git@github.com:wangjinshen/wangjinshen.github.io.git/tags/http-equiv/"}]},{"title":"viewport","slug":"viewport","date":"2019-01-26T03:05:30.000Z","updated":"2019-01-26T03:23:16.000Z","comments":true,"path":"2019/01/26/viewport/","link":"","permalink":"git@github.com:wangjinshen/wangjinshen.github.io.git/2019/01/26/viewport/","excerpt":"","text":"概念：移动设备上的 viewport 就是设备的屏幕上能用来显示我们的网页的那一块区域 语法：1&lt;meta name=\"viewport\" content=\"params1,params2\"&gt; 参数： width：说明：控制视口的宽度，可以指定一个值也可以是一个特殊值代码： 1&lt;meta name=\"viewport\" content=\"width=value\"&gt; height：说明：控制视口的高度，可以指定一个值也可以是一个特殊值代码： 1&lt;meta name=\"viewport\" content=\"height=value\"&gt; initial-scale：说明：页面初始缩放程度，这是一个浮点值，是页面大小的一个乘数。代码： 1&lt;meta name=\"viewport\"content=\"initial-scale=1\"&gt; user-scalable：说明：用户调整缩放，布尔值。代码： 1&lt;meta name=\"viewport\" content=\"width=device-width\"&gt; 总结：1&lt;metaname=\"viewport\"content=\"initial-scale=1,maximum-scale=1,user-scalable=no,width=device-width\"&gt;","categories":[],"tags":[{"name":"viewport","slug":"viewport","permalink":"git@github.com:wangjinshen/wangjinshen.github.io.git/tags/viewport/"}]},{"title":"webpack- 入门","slug":"webpack-入门","date":"2019-01-24T05:40:09.000Z","updated":"2019-02-03T04:44:47.224Z","comments":true,"path":"2019/01/24/webpack-入门/","link":"","permalink":"git@github.com:wangjinshen/wangjinshen.github.io.git/2019/01/24/webpack-入门/","excerpt":"","text":"webpack 入门安装 webpack 和 webpack-cli12npm install webpack -gnpm install webpack-cli -g 目录结构 目录结构 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485const path = require(\"path\")//node中操作路径的内置包const webpack = require(\"webpack\")//引入webpackconst HtmlWebpackPlugin = require(\"html-webpack-plugin\")//引入html-webpack-pluginmodule.exports = &#123; //mode 有两个参数 development本地开发 模式 production生产模式 mode: \"development\", //entry入口 entry: &#123; //入口文件路径 //process.cwd()返回的是当前Node.js进程执行时的工作目录 mian: path.join(process.cwd(), \"src/mian.js\") &#125;, //output出口 output: &#123; //path 输出路径 //dist输出文件没有自动创建 path: path.join(process.cwd(), \"dist\"), //文件名 filename: \"[name].js\" &#125;, //模块 module: &#123; //设定规则 rules: [ &#123; //正则判断文件后缀再用对应得解析器解析 test: /\\.css$/, //解析 从后向前执行 解析css后缀 在以style解析展示 loader: [ \"style-loader\",\"css-loader\"] &#125;, &#123; test: /\\.scss$/, use: [ \"style-loader\", \"css-loader\", \"sass-loader\" ] &#125;, &#123; test: /\\.(png|jpg|gif)$/i, loader: ['url-loader'] &#125; ] &#125;, //配置别名 resolve: &#123; alias: &#123; $vue: \"vue/dist/vue.js\" &#125; &#125;, //本地服务 //要下载依赖 webpack-dev-server devServer: &#123; //自动打开浏览器 open: true, //热服务 hot: true, //主机 host: 'localhost', //端口 port: 8080, //配置接口 before(app) &#123; &#125;, &#125;, //插件 plugins: [ //HotModuleReplacementPlugin webpack内置插件一般和devserver配合使用 new webpack.HotModuleReplacementPlugin(), //拷贝展示页面index 并且把打包后的静态资源引入 new HtmlWebpackPlugin(&#123; //inject // true 默认值，script标签位于html文件的 body 底部 // body script标签位于html文件的 body 底部 // head script标签位于html文件的 head中 // false 不插入生成的js文件，这个几乎不会用到的 inject: \"body\", filename: \"index.html\",//就是html文件的文件名，默认是index.html &#125;) ]&#125; 常用包 webpack-merge 与Object.assign类似,主要作用用于抽离合并 extract-text-webpack-plugin该插件的主要是为了抽离css样式,防止将样式打包在js中引起页面样式加载错乱的现象; cross-env 设置NODE_ENV常量","categories":[],"tags":[{"name":"webpack","slug":"webpack","permalink":"git@github.com:wangjinshen/wangjinshen.github.io.git/tags/webpack/"}]},{"title":"优质博文","slug":"优质博文","date":"2019-01-23T03:49:48.000Z","updated":"2019-01-23T06:38:20.000Z","comments":true,"path":"2019/01/23/优质博文/","link":"","permalink":"git@github.com:wangjinshen/wangjinshen.github.io.git/2019/01/23/优质博文/","excerpt":"","text":"优质博文 Node.js安装及环境配置之Windows篇:https://www.cnblogs.com/zhouyu2017/p/6485265.html mysql server 5.0 安装步骤详解:https://jingyan.baidu.com/article/cbcede0770cab802f50b4d4a.html","categories":[],"tags":[{"name":"学习","slug":"学习","permalink":"git@github.com:wangjinshen/wangjinshen.github.io.git/tags/学习/"},{"name":"工具","slug":"工具","permalink":"git@github.com:wangjinshen/wangjinshen.github.io.git/tags/工具/"}]},{"title":"杂项","slug":"杂项","date":"2019-01-23T01:36:30.000Z","updated":"2019-01-23T03:44:08.000Z","comments":true,"path":"2019/01/23/杂项/","link":"","permalink":"git@github.com:wangjinshen/wangjinshen.github.io.git/2019/01/23/杂项/","excerpt":"","text":"VMware 虚拟机bios计算机领域，BIOS 是 “Basic Input Output System”的缩略语，译为”基本输入输出系统”， [1] 与前者读法相同。计算机在运行时，首先会进入 BIOS，它在计算机系统中起着非常重要的作用。一块主板性能优越与否，很大程度上取决于主板上的 BIOS 管理功能是否先进。 常用 cmd 命令mstsc 链接远程桌面","categories":[],"tags":[]},{"title":"seo工具","slug":"seo工具","date":"2019-01-22T11:06:55.000Z","updated":"2019-01-22T11:40:28.000Z","comments":true,"path":"2019/01/22/seo工具/","link":"","permalink":"git@github.com:wangjinshen/wangjinshen.github.io.git/2019/01/22/seo工具/","excerpt":"","text":"SEO 工具最我网网址: http://www.zui5.com 包含工具 Alexa SEO外链代发工具","categories":[],"tags":[{"name":"seo","slug":"seo","permalink":"git@github.com:wangjinshen/wangjinshen.github.io.git/tags/seo/"}]},{"title":"拖动 -position","slug":"拖动-position","date":"2019-01-22T08:15:31.000Z","updated":"2019-01-22T11:06:22.000Z","comments":true,"path":"2019/01/22/拖动-position/","link":"","permalink":"git@github.com:wangjinshen/wangjinshen.github.io.git/2019/01/22/拖动-position/","excerpt":"","text":"关于一些拖动的小 demodemo先上 demo123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;title&gt;&lt;/title&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1\"&gt; &lt;link href=\"css/style.css\" rel=\"stylesheet\"&gt; &lt;style&gt; * &#123; padding: 0; margin: 0; &#125; .box &#123; width: 200px; height: 200px; background: red; position: fixed; position: relative; top: 20px; left: 20px; &#125; .rightBottom, .left &#123; width: 20px; height: 20px; background: rgba(89, 98, 89, .8); position: absolute; top: 50%; right: 0; transform: translate(50%, -50%); border-radius: 50%; &#125; .rightBottom &#123; top: 100%; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=\"box\"&gt; &lt;div class=\"left\"&gt;&lt;/div&gt; &lt;div class=\"rightBottom\"&gt; &lt;/div&gt; &lt;/div&gt; &lt;script&gt; function $(dom) &#123; return document.querySelector(dom); &#125; $(\".box\").onmousedown = function (e) &#123; e.stopPropagation(); let X = e.offsetX, Y = e.offsetY document.onmousemove = function (e) &#123; e.target.style.left = e.pageX - X + \"px\"; e.target.style.top = e.pageY - Y + \"px\"; &#125; &#125; document.onmouseup = function () &#123; document.onmousemove = null &#125; $(\".left\").onmousedown = function (e) &#123; e.preventDefault(); e.stopPropagation(); let originX = e.pageX, width = $(\".box\").offsetWidth; document.onmousemove = function (e) &#123; $(\".box\").style.width = width + e.pageX - originX + \"px\" &#125; &#125; document.onmouseup = function () &#123; document.onmousemove = null &#125; $(\".rightBottom\").onmousedown = function (e) &#123; e.stopPropagation(); e.preventDefault(); let originX = e.pageX, originY = e.pageY, width = $(\".box\").offsetWidth, height = $(\".box\").offsetHeight; document.onmousemove = function (e) &#123; $(\".box\").style.width = width + e.pageX - originX + \"px\"; $(\".box\").style.height = height + e.pageY - originY + \"px\" &#125; &#125; document.onmouseup = function () &#123; document.onmousemove = null &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 通过事件拿到位置信息的 API12345678910111213141516171819$(\".box\").onmousedown = function (e) &#123; console.log(e) //clientX: 128 //clientY: 87 //点击的点相对view视口原点的距离 // offsetX: 108 // offsetY: 67 //点击的点相对自身原点的距离 // pageX: 128 // pageY: 87 //点击的点相对document原点的距离 // screenX: 348 // screenY: 400 //点击的点相对屏幕原点的距离 &#125; 拖动 dom12345678910111213$(\".box\").onmousedown = function (e) &#123; console.log(e) e.stopPropagation(); let X = e.offsetX, Y = e.offsetY document.onmousemove = function (e) &#123; e.target.style.left = e.pageX - X + \"px\"; e.target.style.top = e.pageY - Y + \"px\"; &#125; &#125; document.onmouseup = function () &#123; document.onmousemove = null &#125; 通过拖动改变 dom 宽度123456789101112$(\".left\").onmousedown = function (e) &#123; e.preventDefault(); e.stopPropagation(); let originX = e.pageX, width = $(\".box\").offsetWidth; document.onmousemove = function (e) &#123; $(\".box\").style.width = width + e.pageX - originX + \"px\" &#125; &#125; document.onmouseup = function () &#123; document.onmousemove = null &#125; 通过拖动改变 dom 宽度和高度12345678910111213141516171819202122$(\".rightBottom\").onmousedown = function (e) &#123; //阻止冒泡 e.stopPropagation(); //取消默认事件 e.preventDefault(); //按下时获取到当前点击的原点 let originX = e.pageX, originY = e.pageY, //按下时获取到当前元素的宽度和高度 width = $(\".box\").offsetWidth, height = $(\".box\").offsetHeight; document.onmousemove = function (e) &#123; //e.pageX - originX // 移动时鼠标的距离原点的距离减去按下时原点的距离==要加的宽度或要减得宽度 $(\".box\").style.width = width + e.pageX - originX + \"px\"; $(\".box\").style.height = height + e.pageY - originY + \"px\" &#125; &#125; document.onmouseup = function () &#123; //抬起取消移动事件 document.onmousemove = null &#125; 元素距离的一些获取方式 $(“.box”).clientWidth; $(“.box”).clientHeight; $(“.box”).offsetWidth （包含边线的宽） $(“.box”).offsetHeight （包含边线的高）; $(“.box”).offsetLeft (dom 元素距离定位元素的 left 父元素没有定位层层向上直到 document) $(“.box”).offsetTop (dom 元素距离定位元素的 Top 父元素没有定位层层向上直到 document) $(“.box”) 正文全文宽： $(“.box”).scrollWidth;（含滚动条时，即滚动条从最顶端滚到最底端实际走过的距离） $(“.box”) 正文全文高： $(“.box”).scrollHeight;（含滚动条时，即滚动条从最顶端滚到最底端实际走过的距离） $(“.box”) 被卷去的高： $(“.box”).scrollTop; $(“.box”) 被卷去的左： $(“.box”).scrollLeft;","categories":[],"tags":[{"name":"dom","slug":"dom","permalink":"git@github.com:wangjinshen/wangjinshen.github.io.git/tags/dom/"},{"name":"position","slug":"position","permalink":"git@github.com:wangjinshen/wangjinshen.github.io.git/tags/position/"}]},{"title":"react对象控制台输出 null 的问题","slug":"react合成事件对象控制台输出null的问题","date":"2019-01-20T11:24:35.000Z","updated":"2019-01-20T12:09:04.000Z","comments":true,"path":"2019/01/20/react合成事件对象控制台输出null的问题/","link":"","permalink":"git@github.com:wangjinshen/wangjinshen.github.io.git/2019/01/20/react合成事件对象控制台输出null的问题/","excerpt":"","text":"react 中 event 对象控制台输出 null 的问题在 react 中输出 event 对象，在控制台查看是 null null 解决的办法很简单，在 console.log(event) 前使用 event 的 persist() 方法即可。1234567891011121314import React, &#123; Component &#125; from 'react';class App extends Component &#123; render() &#123; return &lt;div onClick=&#123; (e)=&gt;&#123; e.persist() console.log(e) &#125; &#125;&gt; 点击 &lt;/div&gt;; &#125;;&#125;;export default App; 结果 结果","categories":[],"tags":[{"name":"react","slug":"react","permalink":"git@github.com:wangjinshen/wangjinshen.github.io.git/tags/react/"}]},{"title":"redux-persist- 数据持久化","slug":"redux-persist-数据持久化","date":"2019-01-19T12:36:42.000Z","updated":"2019-01-19T13:03:44.000Z","comments":true,"path":"2019/01/19/redux-persist-数据持久化/","link":"","permalink":"git@github.com:wangjinshen/wangjinshen.github.io.git/2019/01/19/redux-persist-数据持久化/","excerpt":"","text":"安装1npm install redux-persist 基本用法12345678910111213141516171819202122232425262728293031323334// configureStore.js//引入reduximport &#123; createStore &#125; from 'redux'import &#123; persistStore, persistReducer &#125; from 'redux-persist'import storage from 'redux-persist/lib/storage' //defaults to localStorage for web and AsyncStorage for react-native 存到localStorage中//默认Storeconst initialState=&#123; data：[] &#125;//订阅事件const rootReducer = (state = initialState, &#123; type, payload &#125;) =&gt; &#123; switch (type) &#123; case \"UPDATE\": &#123; return &#123; ...state, data: [...payload] &#125; &#125; default: return state &#125;&#125;const persistConfig = &#123; key: 'root', storage,&#125;const persistedReducer = persistReducer(persistConfig, rootReducer)export default () =&gt; &#123; let store = createStore(persistedReducer) let persistor = persistStore(store) return &#123; store, persistor &#125;&#125;","categories":[],"tags":[{"name":"react","slug":"react","permalink":"git@github.com:wangjinshen/wangjinshen.github.io.git/tags/react/"},{"name":"redux","slug":"redux","permalink":"git@github.com:wangjinshen/wangjinshen.github.io.git/tags/redux/"}]},{"title":"node-fetch 跨域","slug":"node-fetch跨域","date":"2019-01-19T11:46:48.000Z","updated":"2019-01-19T12:05:16.000Z","comments":true,"path":"2019/01/19/node-fetch跨域/","link":"","permalink":"git@github.com:wangjinshen/wangjinshen.github.io.git/2019/01/19/node-fetch跨域/","excerpt":"","text":"node-fetch安装12npm install node-fetch --saveyarn add node-fetch 引入使用get 请求12345678910111213var fetch = require(\"node-fetch\")module.exports = &#123; searchResult(str,statr,end) &#123; str = encodeURIComponent(str) return new Promise((result, reject) =&gt; &#123; fetch(\"https://www.xiachufang.com/juno/weapp/v2/search/universal_search.json?q=\" + str + \"&amp;\" + \"offset=\" + statr + \"&amp;\" + \"limit=\" + end).then(res =&gt; res.text() ).then(response =&gt; result(response) ); &#125;) &#125;&#125; post 请求123456789101112131415var fetch = require(\"node-fetch\")module.exports = &#123; searchPOST(str,statr,end) &#123; return new Promise((result, reject) =&gt; &#123; const body = &#123; a: end,b:statr &#125;; fetch('https://httpbin.org/post', &#123; method: 'post', body: JSON.stringify(body), &#125;) .then(res =&gt; res.text()) .then(response =&gt; result(response)); &#125; &#125;&#125; npm地址： https://www.npmjs.com/package/node-fetch","categories":[],"tags":[{"name":"node","slug":"node","permalink":"git@github.com:wangjinshen/wangjinshen.github.io.git/tags/node/"},{"name":"跨域","slug":"跨域","permalink":"git@github.com:wangjinshen/wangjinshen.github.io.git/tags/跨域/"},{"name":"node-fetch","slug":"node-fetch","permalink":"git@github.com:wangjinshen/wangjinshen.github.io.git/tags/node-fetch/"}]},{"title":"谷歌","slug":"谷歌","date":"2019-01-19T05:41:19.000Z","updated":"2019-01-19T05:43:42.000Z","comments":true,"path":"2019/01/19/谷歌/","link":"","permalink":"git@github.com:wangjinshen/wangjinshen.github.io.git/2019/01/19/谷歌/","excerpt":"","text":"学习地址https://github.com/bannedbook","categories":[],"tags":[{"name":"【谷歌】","slug":"【谷歌】","permalink":"git@github.com:wangjinshen/wangjinshen.github.io.git/tags/【谷歌】/"}]},{"title":"node- 连接 mysql","slug":"mysql-连接池","date":"2019-01-19T02:37:30.000Z","updated":"2019-02-15T15:06:03.097Z","comments":true,"path":"2019/01/19/mysql-连接池/","link":"","permalink":"git@github.com:wangjinshen/wangjinshen.github.io.git/2019/01/19/mysql-连接池/","excerpt":"","text":"node- 连接 -mysql下载 mysql12yarn add mysqlnpm install mysql 引入 mysql123456789101112131415//引入包var mysql = require('mysql');//建立连接关系配置var config = &#123; //ip host : 'localhost', //mysql用户名 默认root user : 'me', //mysql用户密码 password : 'secret', //库名 database : 'my_db', port: 3306&#125;; node 与 mysql 的普通连接123456789101112131415161718function query(sql, callback) &#123; //建立联系 var connection = mysql.createConnection(config); //监听连接是否成功 不成功抛出错误 connection.connect(function(err) &#123; console.log(err) &#125;); //查询 connection.query(sql, function(qerr, rows, fields) &#123; //关闭数据库连接 connection.end(function(err) &#123; console.log(err) &#125;); //事件驱动回调 callback(qerr, rows, fields); &#125;);&#125;//使用query(\"mysql语句\",callback(err,rows, fields)&#123; //err 错误信息 //rows 结果&#125;) node 链接 mysql 创建连接池1234567891011121314151617let connection=mysql.createPool(config.dev_sql_config)const query=(sql)=&gt;&#123; return new Promise((resolve,reject)=&gt;&#123; connection.getConnection((err,connect)=&gt;&#123; connect.query(sql,(sqlerr,rows,fields)=&gt;&#123; if(err)&#123; console.log(err) reject(err) return &#125; resolve(rows) //释放连接 connect.release() &#125;) &#125;) &#125;)&#125; 常用数据库操作语句表查询语句字符串查询范围123select * from school where id=’aa’select * from school where id=’aa’ and name=“name” 数值查询范围1select id,name from school where num&gt;1 模糊查询1select * from school where name like ‘% 陈 %’ 数据截取（截取前十条数据）1select * from school limit 0,10 数据查询排序 (desc 降序，asc 升序）1select * from school limit 0,10 order by desc 表连接查询（多表查询，表结构相同）1\"select * from (select * from table_a UNION ALL select * from table_b)as tabel_all \" 表插入语句单纯插入表数据1insert into tabel_a(id,name) values(1,”chen”) 创建新表，并复制另外一个表格中的数据1select id,name into tabel_b from table_a 复制另外一个表中数据进行插入1insert into tabte_b(id,name) select id，name from tabel_a 删除表数据1delete from class_one_list where id=‘1’ 更新表数据1update class_one_list set twoListNum=’1’,artListNum=’2’ where id=’2’ 创建表1CREATE TABLE person (number INT(11), name VARCHAR(255), birthday DATE); 修改表名1alter table table_name rename table_new_name 删除表1DROP TABLE tbl_name;","categories":[],"tags":[{"name":"node","slug":"node","permalink":"git@github.com:wangjinshen/wangjinshen.github.io.git/tags/node/"},{"name":"mysql","slug":"mysql","permalink":"git@github.com:wangjinshen/wangjinshen.github.io.git/tags/mysql/"}]},{"title":"vue-router","slug":"vue-route","date":"2019-01-18T01:03:28.000Z","updated":"2019-01-28T06:06:48.000Z","comments":true,"path":"2019/01/18/vue-route/","link":"","permalink":"git@github.com:wangjinshen/wangjinshen.github.io.git/2019/01/18/vue-route/","excerpt":"","text":"route安装 vue-roter12npm install vue-router --save-devyarn add vue-router -dev init 使用123456789101112131415161718192021222324 import VueRouter form \"vue-router\"// 挂载在全局上 Vue.use(VueRouter) //实例 const route = new VueRouter(&#123; // 配置路由 routes:[ &#123; // 路由地址 path: '/', // 当路由是默认 \"/\" 时加载”/index 路由 redirect: '/index' &#125;, &#123; path:\"/index\"， // 在&lt;router-view&gt;&lt;/router-view&gt;显示的内容组件 component:index，//index 是一个组件 &#125; ] &#125;) 页面配置1&lt;router-view&gt;&lt;/router-view&gt;标签 显示路由中 component 引进的内容 切换路由12345678910&lt;router-link to=&quot;/index&quot; tag=&quot;span&quot;&gt;index&lt;/router-link&gt;to: 属性制指定跳转到某一个路由 例：/index 当点击后&lt;router-view&gt;&lt;/router-view&gt;内将会显示 /index 中的组件tsg：指定在页面中显示出什么类型的 的标签 例如：tag=&quot;span&quot; 在以页面中 &lt;router-link&gt;标签会转为 span 标签显示 导航守卫导航”表示路由正在发生改变。主要用来通过跳转或取消的方式守卫导航 有多种机会植入路由导航过程中：全局的，单个路由独享的，或者组件级的。 参数或查询的改变并不会触发进入 / 离开的导航守卫 route.beforeEachroute 是 vue-router 的实例 注册一个全局前置守卫：route.beforeEach(to,from,next){ } to: 即将要进入的目标 路由对象 from: 当前导航正要离开的路由 next: 一定要调用该方法来 resolve 这个钩子。执行效果依赖 next 方法的调用参数。不调用不执行 next(): 进行管道中的下一个钩子。如果全部钩子执行完了，则导航的状态就是 confirmed （确认的）。 next(false): 中断当前的导航。如果浏览器的 URL 改变了 （可能是用户手动或者浏览器后退按钮），那么 URL 地址会重置到 from 路由对应的地址。 next(&#39;/&#39;) 或者 next({ path: &#39;/&#39; })：跳转到一个不同的地址。当前的导航被中断，然后进行一个新的导航。你可以向 next 传递任意位置对象且允许设置诸如replace: true、name: &#39;home&#39;之类的选项以及任何用在 router-link 的 to prop或 router.push 中的选项。 全局解析首位2.5.0+ 你可以用router.beforeResolve 注册一个全局守卫。这和 router.beforeEach 类似，区别是在导航被确认之前，同时在所有组件内守卫和异步路由组件被解析之后，解析守卫就被调用。 全局后置钩子你也可以注册全局后置钩子，然而和守卫不同的是，这些钩子不会接受 next 函数也不会改变导航本身： 123router.afterEach((to, from) =&gt; &#123;// ...&#125;) 路由独享的守卫可以在路由配置上直接定义 beforeEnter 例如： 1234567891011const router = new VueRouter(&#123;routes: [ &#123; path: '/foo', component: Foo, beforeEnter: (to, from, next) =&gt; &#123; // ... &#125; &#125;]&#125;) 组件内的守卫123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960const Foo = &#123;template: `...`,beforeRouteEnter (to, from, next) &#123;// 在渲染该组件的对应路由被 confirm 前调用// 不！能！获取组件实例 `this`// 因为当守卫执行前，组件实例还没被创建&#125;,beforeRouteUpdate (to, from, next) &#123;// 在当前路由改变，但是该组件被复用时调用// 举例来说，对于一个带有动态参数的路径 /foo/:id，在 /foo/1 和 /foo/2 之间跳转的时候，// 由于会渲染同样的 Foo 组件，因此组件实例会被复用。而这个钩子就会在这个情况下被调用。// 可以访问组件实例 `this`&#125;,beforeRouteLeave (to, from, next) &#123;// 导航离开该组件的对应路由时调用// 可以访问组件实例 `this`&#125;&#125;&lt;script&gt;export default &#123;beforeRouteEnter (to, from, next) &#123;console.log(to)next()&#125;,props:&#123;&#125;,components:&#123;&#125;,data()&#123;return &#123;&#125;&#125;,computed:&#123;&#125;,methods:&#123;&#125;,created()&#123;&#125;,mounted()&#123;&#125;&#125;&lt;/script&gt; beforRouteEnter 不能获取到 this 但是也可通 next 的回调函数获取 12345beforeRouteEnter (to, from, next) &#123; next(vm =&gt; &#123; // 通过 vm 访问组件实例 &#125;)&#125; 这个离开守卫通常用来禁止用户在还未保存修改前突然离开。该导航可以通过 next(false) 来取消。 1234567891011beforeRouteLeave (to, from , next) &#123; const answer = window.confirm('Do you really want to leave? you have unsaved changes!') if (answer) &#123; // 为 true 就执行跳转路由 next() &#125; else &#123; 反之就停止跳转 留在当前的路由 next(false) &#125;&#125; 完整的导航解析流程 导航被触发。 在失活的组件里调用离开守卫。 调用全局的 beforeEach 守卫。 在重用的组件里调用 beforeRouteUpdate 守卫 (2.2+)。 在路由配置里调用 beforeEnter。 解析异步路由组件。 在被激活的组件里调用 beforeRouteEnter。 调用全局的 beforeResolve 守卫 (2.5+)。 导航被确认。 调用全局的 afterEach 钩子。 触发 DOM 更新。 用创建好的实例调用 beforeRouteEnter 守卫中传给 next 的回调函数。","categories":[],"tags":[{"name":"vue","slug":"vue","permalink":"git@github.com:wangjinshen/wangjinshen.github.io.git/tags/vue/"},{"name":"router","slug":"router","permalink":"git@github.com:wangjinshen/wangjinshen.github.io.git/tags/router/"}]},{"title":"redux-action","slug":"action","date":"2019-01-16T12:57:34.000Z","updated":"2019-01-28T06:09:58.000Z","comments":true,"path":"2019/01/16/action/","link":"","permalink":"git@github.com:wangjinshen/wangjinshen.github.io.git/2019/01/16/action/","excerpt":"","text":"wepy-redux安装1cnpm install redux redux-actions redux-promise wepy-redux --save 创建 store12345678910import &#123; createStore, applyMiddleware &#125; from \"redux\";import Reducers from \"./reducer\";import promiseMiddleware from \"redux-promise\";//写法一：export default function configStore() &#123; return createStore(Reducers, applyMiddleware(promiseMiddleware))&#125;//写法二export default createStore(Reducers, applyMiddleware(promiseMiddleware)) 创建 reducerrank.js123456789101112131415const defaultState = &#123; rankList: [1, 2, 3]&#125;const rankReducer = (state = defaultState, action) =&gt; &#123; const &#123; type, payload &#125; = action; switch (type) &#123; case \"UPDATE\": return &#123; ...state, rankList: payload &#125; default: return state; &#125;&#125;export default rankReducer; index.js1234567891011121314import &#123; combineReducers &#125; from \"redux\";import rankReducer from \"./rank\";import topListReducer from \"./toplist\";import searchReducer from \"./search\";const Reducers = combineReducers(&#123; rankReducer, topListReducer, searchReducer, ...&#125;)export default Reducers; 创建 action12345678910111213141516171819202122import &#123; RNAK_UPDATE &#125; from \"../type/rank\";import &#123; createAction &#125; from \"redux-actions\";import axios from \"@/utils/request\";//方式一:export function update(payload) &#123; return &#123; type: RNAK_UPDATE, payload &#125;&#125;//方式二：const getJson = async function(url) &#123; let result = await axios.get(url); return result.data.data.slider;&#125;export const update = createAction(RNAK_UPDATE, () =&gt; &#123; const url = \"https://c.y.qq.com/musichall/fcgi-bin/fcg_yqqhomepagerecommend.fcg\"; return getJson(url);&#125;) 创建 type12export const RNAK_UPDATE = \"UPDATE\";export const TOPLIST_UPDATE = \"UPDATE\"; 绑定及监听在app.wepy文件中，添加下面代码：123import &#123; setStore &#125; from 'wepy-redux'import store from './store'setStore(store) setStore()是用来将仓库中的数据绑定到页面中 类似react-redux中的 &lt;Provider store={store}&gt;&lt;/Provider&gt;组件","categories":[],"tags":[{"name":"react","slug":"react","permalink":"git@github.com:wangjinshen/wangjinshen.github.io.git/tags/react/"},{"name":"redux","slug":"redux","permalink":"git@github.com:wangjinshen/wangjinshen.github.io.git/tags/redux/"}]},{"title":"react-component-父子通讯","slug":"react-component-父子通讯","date":"2019-01-16T10:13:12.000Z","updated":"2019-01-16T12:53:54.000Z","comments":true,"path":"2019/01/16/react-component-父子通讯/","link":"","permalink":"git@github.com:wangjinshen/wangjinshen.github.io.git/2019/01/16/react-component-父子通讯/","excerpt":"","text":"组件通讯父子通讯父级组件调用子组件，通过props来传递参数，子组件通过this.props来接收 1234567891011121314151617181920import React from \"react\";class Children extends React.Component&#123; render()&#123; const &#123; datalist &#125; = this.props; return &lt;div&gt; &lt;/div&gt; &#125;&#125;class Parent extends React.Component&#123; render()&#123; const &#123; datalist &#125; = []; return &lt;div&gt; &lt;Children datalist=&#123;datalist&#125;&gt;&lt;/Children&gt; &lt;/div&gt; &#125;&#125; 子父通讯父级组件通过props给子组件传递一个回调函数，子级组件调用父级传递过来的回调，将参数返回1234567891011121314151617181920212223242526import React from \"react\";class Children extends React.Component&#123; componentDidMount()&#123; const &#123; getData &#125; = this.props; getData([1,2,3,4,5]) &#125; render()&#123; return &lt;div&gt; this is children &lt;/div&gt; &#125;&#125;class Parent extends React.Component&#123; getData(val)&#123; //[1,2,3,4,5] console.log(val) &#125; render()&#123; return &lt;div&gt; &lt;Children getData=&#123;this.getData&#125;&gt;&lt;/Children&gt; &lt;/div&gt; &#125;&#125; 同级通讯1npm install --save events 12345678910const EventEmitter = require('events') const EventBus = new EventEmitter()//事件订阅EventBus.on(\"message\", function (text) &#123; console.log(text) //hello world&#125;)//事件发布EventBus.emit(\"message\", 'hello world') 跨级通讯案例描述: 当前有三个组件，包裹顺序依次是： Parent &gt; Middle &gt; Children现在 Parent组件有数据要传递给 Children组件 Parent &gt; Middle &gt; Children具体方案请参考 props 传参 Parent &gt; Children具体方案如下，通context对象完成数据传递： 12345678910111213141516171819202122232425262728293031323334353637383940414243import React from \"react\";import PropTypes from \"prop-types\";// 子级class Children extends React.Component&#123; static contextTypes = &#123; propA: PropTypes.string methodA: PropTypes.func &#125; render()&#123; return &lt;div&gt; this is children: &#123;this.context.propA&#125; &lt;/div&gt; &#125;&#125;// 中间class Middle extends React.Component &#123; render () &#123; return &lt;Children /&gt; &#125;&#125;// 父级class Parent extends React.Component&#123; // 声明Context对象属性 static childContextTypes = &#123; propA: PropTypes.string, methodA: PropTypes.func &#125; // 返回Context对象，方法名是约定好的 getChildContext () &#123; return &#123; propA: 'propA', methodA: () =&gt; 'methodA' &#125; &#125; render()&#123; return &lt;div&gt; &lt;Middle/&gt; &lt;/div&gt; &#125;&#125; redux全局状态的管理库，详情请看redux指南","categories":[],"tags":[{"name":"react","slug":"react","permalink":"git@github.com:wangjinshen/wangjinshen.github.io.git/tags/react/"}]},{"title":"vue 安装","slug":"vue安装","date":"2018-01-23T12:05:15.000Z","updated":"2019-01-28T06:10:50.000Z","comments":true,"path":"2018/01/23/vue安装/","link":"","permalink":"git@github.com:wangjinshen/wangjinshen.github.io.git/2018/01/23/vue安装/","excerpt":"","text":"vue 安装安装全局 vue 和 vue-cli 12cnpm install vuecnpm install --global vue-cli 命令行工具123456789101112131415161718192021222324252627 全局安装 vue-cli$ cnpm install --global vue-cli 创建一个基于 webpack 模板的新项目$ vue init webpack my-project 这里需要进行一些配置，默认回车即可This will install Vue 2.x version of the template.For Vue 1.x use: vue init webpack#1.0 my-project? Project name my-project? Project description A Vue.js project? Author runoob &lt;test@runoob.com&gt;? Vue build standalone? Use ESLint to lint your code? Yes? Pick an ESLint preset Standard? Setup unit tests with Karma + Mocha? Yes? Setup e2e tests with Nightwatch? Yes vue-cli · Generated \"my-project\". To get started: cd my-project npm install npm run dev Documentation can be found at https://vuejs-templates.github.io/webpack 进入项目，安装并运行：123456$ cd my-project$ cnpm install$ cnpm run dev DONE Compiled successfully in 4388ms&gt; Listening at http://localhost:8080 成功执行以上命令后访问 http://localhost:8080/，输出结果如下所示： 如图","categories":[],"tags":[{"name":"vue","slug":"vue","permalink":"git@github.com:wangjinshen/wangjinshen.github.io.git/tags/vue/"}]}]}