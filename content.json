{"meta":{"title":"阿王","subtitle":"做一个爱折腾的程序员","description":"做一个爱折腾的程序员","author":"王瑾深","url":"http://yoursite.com"},"pages":[{"title":"tags","date":"2019-01-16T00:44:54.271Z","updated":"2019-01-16T00:44:54.271Z","comments":false,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""},{"title":"archives","date":"2019-01-16T00:17:08.000Z","updated":"2019-01-16T00:17:08.993Z","comments":true,"path":"archives/index.html","permalink":"http://yoursite.com/archives/index.html","excerpt":"","text":""}],"posts":[{"title":"node-fetch 跨域","slug":"node-fetch跨域","date":"2019-01-19T11:46:48.000Z","updated":"2019-01-19T12:04:06.843Z","comments":true,"path":"2019/01/19/node-fetch跨域/","link":"","permalink":"http://yoursite.com/2019/01/19/node-fetch跨域/","excerpt":"","text":"node-fetch安装12npm install node-fetch --saveyarn add node-fetch 引入使用get 请求12345678910111213var fetch = require(\"node-fetch\")module.exports = &#123; searchResult(str,statr,end) &#123; str = encodeURIComponent(str) return new Promise((result, reject) =&gt; &#123; fetch(\"https://www.xiachufang.com/juno/weapp/v2/search/universal_search.json?q=\" + str + \"&amp;\" + \"offset=\" + statr + \"&amp;\" + \"limit=\" + end).then(res =&gt; res.text() ).then(response =&gt; result(response) ); &#125;) &#125;&#125; post 请求123456789101112131415var fetch = require(\"node-fetch\")module.exports = &#123; searchPOST(str,statr,end) &#123; return new Promise((result, reject) =&gt; &#123; const body = &#123; a: end,b:statr &#125;; fetch('https://httpbin.org/post', &#123; method: 'post', body: JSON.stringify(body), &#125;) .then(res =&gt; res.text()) .then(response =&gt; result(response)); &#125; &#125;&#125; npm地址： https://www.npmjs.com/package/node-fetch","categories":[],"tags":[{"name":"node","slug":"node","permalink":"http://yoursite.com/tags/node/"},{"name":"跨域，node-fetch","slug":"跨域，node-fetch","permalink":"http://yoursite.com/tags/跨域，node-fetch/"}]},{"title":"谷歌","slug":"谷歌","date":"2019-01-19T05:41:19.000Z","updated":"2019-01-19T05:43:40.029Z","comments":true,"path":"2019/01/19/谷歌/","link":"","permalink":"http://yoursite.com/2019/01/19/谷歌/","excerpt":"","text":"学习地址https://github.com/bannedbook","categories":[],"tags":[{"name":"【谷歌】","slug":"【谷歌】","permalink":"http://yoursite.com/tags/【谷歌】/"}]},{"title":"node- 连接 mysql","slug":"mysql-连接池","date":"2019-01-19T02:37:30.000Z","updated":"2019-01-19T03:24:24.122Z","comments":true,"path":"2019/01/19/mysql-连接池/","link":"","permalink":"http://yoursite.com/2019/01/19/mysql-连接池/","excerpt":"","text":"node- 连接 -mysql下载 mysql12yarn add mysqlnpm install mysql 引入 mysql12345678910111213//引入包var mysql = require('mysql');//建立连接关系配置var config = &#123; //ip host : 'localhost', //mysql用户名 默认root user : 'me', //mysql用户密码 password : 'secret', //库名 database : 'my_db'&#125;; node 与 mysql 的普通连接123456789101112131415161718function query(sql, callback) &#123; //建立联系 var connection = mysql.createConnection(config); //监听连接是否成功 不成功抛出错误 connection.connect(function(err) &#123; console.log(err) &#125;); //查询 connection.query(sql, function(qerr, rows, fields) &#123; //关闭数据库连接 connection.end(function(err) &#123; console.log(err) &#125;); //事件驱动回调 callback(qerr, rows, fields); &#125;);&#125;//使用query(\"mysql语句\",callback(err,rows, fields)&#123; //err 错误信息 //rows 结果&#125;) node 链接 mysql 创建连接池1234567891011121314151617let connection=mysql.createPool(config.dev_sql_config)const query=(sql)=&gt;&#123; return new Promise((resolve,reject)=&gt;&#123; connection.getConnection((err,connect)=&gt;&#123; connect.query(sql,(sqlerr,rows,fields)=&gt;&#123; if(err)&#123; console.log(err) reject(err) return &#125; resolve(rows) //释放连接 connect.release() &#125;) &#125;) &#125;)&#125; 常用数据库操作语句表查询语句字符串查询范围1select * from school where id=’aa’ 数值查询范围1select id,name from school where num&gt;1 模糊查询1select * from school where name like ‘% 陈 %’ 数据截取（截取前十条数据）1select * from school limit 0,10 数据查询排序 (desc 降序，asc 升序）1select * from school limit 0,10 order by desc 表连接查询（多表查询，表结构相同）1\"select * from (select * from table_a UNION ALL select * from table_b)as tabel_all \" 表插入语句单纯插入表数据1insert into tabel_a(id,name) values(1,”chen”) 创建新表，并复制另外一个表格中的数据1select id,name into tabel_b from table_a 复制另外一个表中数据进行插入1insert into tabte_b(id,name) select id，name from tabel_a 删除表数据1delete from class_one_list where id=‘1’ 更新表数据1update class_one_list set twoListNum=’1’,artListNum=’2’ where id=’2’ 创建表1CREATE TABLE person (number INT(11), name VARCHAR(255), birthday DATE); 修改表名1alter table table_name rename table_new_name 删除表1DROP TABLE tbl_name;","categories":[],"tags":[{"name":"node","slug":"node","permalink":"http://yoursite.com/tags/node/"},{"name":"mysql","slug":"mysql","permalink":"http://yoursite.com/tags/mysql/"}]},{"title":"vue-router","slug":"vue-route","date":"2019-01-18T01:03:28.000Z","updated":"2019-01-18T01:15:10.268Z","comments":true,"path":"2019/01/18/vue-route/","link":"","permalink":"http://yoursite.com/2019/01/18/vue-route/","excerpt":"","text":"route安装 vue-roter12npm install vue-router --save-devyarn add vue-router -dev init 使用123456789101112131415161718192021222324import VueRouter form \"vue-router\"挂载在全局上Vue.use(VueRouter)实例const route = new VueRouter(&#123; // 配置路由 routes:[ &#123; // 路由地址 path: '/', // 当路由是默认 \"/\" 时加载”/index 路由 redirect: '/index' &#125;, &#123; path:\"/index\"， // 在&lt;router-view&gt;&lt;/router-view&gt;显示的内容组件 component:index，//index 是一个组件 &#125; ]&#125;) 页面配置1&lt;router-view&gt;&lt;/router-view&gt;标签 显示路由中 component 引进的内容 切换路由12345678910&lt;router-link to=&quot;/index&quot; tag=&quot;span&quot;&gt;index&lt;/router-link&gt;to: 属性制指定跳转到某一个路由 例：/index 当点击后&lt;router-view&gt;&lt;/router-view&gt;内将会显示 /index 中的组件tsg：指定在页面中显示出什么类型的 的标签 例如：tag=&quot;span&quot; 在以页面中 &lt;router-link&gt;标签会转为 span 标签显示 导航守卫导航”表示路由正在发生改变。主要用来通过跳转或取消的方式守卫导航 有多种机会植入路由导航过程中：全局的，单个路由独享的，或者组件级的。 参数或查询的改变并不会触发进入 / 离开的导航守卫 route.beforeEachroute 是 vue-router 的实例 注册一个全局前置守卫：route.beforeEach(to,from,next){ } to: 即将要进入的目标 路由对象 from: 当前导航正要离开的路由 next: 一定要调用该方法来 resolve 这个钩子。执行效果依赖 next 方法的调用参数。不调用不执行 next(): 进行管道中的下一个钩子。如果全部钩子执行完了，则导航的状态就是 confirmed （确认的）。 next(false): 中断当前的导航。如果浏览器的 URL 改变了 （可能是用户手动或者浏览器后退按钮），那么 URL 地址会重置到 from 路由对应的地址。 next(&#39;/&#39;) 或者 next({ path: &#39;/&#39; })：跳转到一个不同的地址。当前的导航被中断，然后进行一个新的导航。你可以向 next 传递任意位置对象且允许设置诸如replace: true、name: &#39;home&#39;之类的选项以及任何用在 router-link 的 to prop或 router.push 中的选项。 全局解析首位2.5.0+ 你可以用router.beforeResolve 注册一个全局守卫。这和 router.beforeEach 类似，区别是在导航被确认之前，同时在所有组件内守卫和异步路由组件被解析之后，解析守卫就被调用。 全局后置钩子你也可以注册全局后置钩子，然而和守卫不同的是，这些钩子不会接受 next 函数也不会改变导航本身： 123router.afterEach((to, from) =&gt; &#123;// ...&#125;) 路由独享的守卫可以在路由配置上直接定义 beforeEnter 例如： 1234567891011const router = new VueRouter(&#123;routes: [ &#123; path: '/foo', component: Foo, beforeEnter: (to, from, next) =&gt; &#123; // ... &#125; &#125;]&#125;) 组件内的守卫123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960const Foo = &#123;template: `...`,beforeRouteEnter (to, from, next) &#123;// 在渲染该组件的对应路由被 confirm 前调用// 不！能！获取组件实例 `this`// 因为当守卫执行前，组件实例还没被创建&#125;,beforeRouteUpdate (to, from, next) &#123;// 在当前路由改变，但是该组件被复用时调用// 举例来说，对于一个带有动态参数的路径 /foo/:id，在 /foo/1 和 /foo/2 之间跳转的时候，// 由于会渲染同样的 Foo 组件，因此组件实例会被复用。而这个钩子就会在这个情况下被调用。// 可以访问组件实例 `this`&#125;,beforeRouteLeave (to, from, next) &#123;// 导航离开该组件的对应路由时调用// 可以访问组件实例 `this`&#125;&#125;&lt;script&gt;export default &#123;beforeRouteEnter (to, from, next) &#123;console.log(to)next()&#125;,props:&#123;&#125;,components:&#123;&#125;,data()&#123;return &#123;&#125;&#125;,computed:&#123;&#125;,methods:&#123;&#125;,created()&#123;&#125;,mounted()&#123;&#125;&#125;&lt;/script&gt; beforRouteEnter 不能获取到 this 但是也可通 next 的回调函数获取 12345beforeRouteEnter (to, from, next) &#123; next(vm =&gt; &#123; // 通过 vm 访问组件实例 &#125;)&#125; 这个离开守卫通常用来禁止用户在还未保存修改前突然离开。该导航可以通过 next(false) 来取消。 1234567891011beforeRouteLeave (to, from , next) &#123; const answer = window.confirm('Do you really want to leave? you have unsaved changes!') if (answer) &#123; // 为 true 就执行跳转路由 next() &#125; else &#123; 反之就停止跳转 留在当前的路由 next(false) &#125;&#125; 完整的导航解析流程 导航被触发。 在失活的组件里调用离开守卫。 调用全局的 beforeEach 守卫。 在重用的组件里调用 beforeRouteUpdate 守卫 (2.2+)。 在路由配置里调用 beforeEnter。 解析异步路由组件。 在被激活的组件里调用 beforeRouteEnter。 调用全局的 beforeResolve 守卫 (2.5+)。 导航被确认。 调用全局的 afterEach 钩子。 触发 DOM 更新。 用创建好的实例调用 beforeRouteEnter 守卫中传给 next 的回调函数。","categories":[],"tags":[{"name":"vue","slug":"vue","permalink":"http://yoursite.com/tags/vue/"},{"name":"router","slug":"router","permalink":"http://yoursite.com/tags/router/"}]},{"title":"action","slug":"action","date":"2019-01-16T12:57:34.000Z","updated":"2019-01-16T13:00:03.199Z","comments":true,"path":"2019/01/16/action/","link":"","permalink":"http://yoursite.com/2019/01/16/action/","excerpt":"","text":"wepy-redux安装1cnpm install redux redux-actions redux-promise wepy-redux --save 创建 store12345678910import &#123; createStore, applyMiddleware &#125; from \"redux\";import Reducers from \"./reducer\";import promiseMiddleware from \"redux-promise\";//写法一：export default function configStore() &#123; return createStore(Reducers, applyMiddleware(promiseMiddleware))&#125;//写法二export default createStore(Reducers, applyMiddleware(promiseMiddleware)) 创建 reducerrank.js123456789101112131415const defaultState = &#123; rankList: [1, 2, 3]&#125;const rankReducer = (state = defaultState, action) =&gt; &#123; const &#123; type, payload &#125; = action; switch (type) &#123; case \"UPDATE\": return &#123; ...state, rankList: payload &#125; default: return state; &#125;&#125;export default rankReducer; index.js1234567891011121314import &#123; combineReducers &#125; from \"redux\";import rankReducer from \"./rank\";import topListReducer from \"./toplist\";import searchReducer from \"./search\";const Reducers = combineReducers(&#123; rankReducer, topListReducer, searchReducer, ...&#125;)export default Reducers; 创建 action12345678910111213141516171819202122import &#123; RNAK_UPDATE &#125; from \"../type/rank\";import &#123; createAction &#125; from \"redux-actions\";import axios from \"@/utils/request\";//方式一:export function update(payload) &#123; return &#123; type: RNAK_UPDATE, payload &#125;&#125;//方式二：const getJson = async function(url) &#123; let result = await axios.get(url); return result.data.data.slider;&#125;export const update = createAction(RNAK_UPDATE, () =&gt; &#123; const url = \"https://c.y.qq.com/musichall/fcgi-bin/fcg_yqqhomepagerecommend.fcg\"; return getJson(url);&#125;) 创建 type12export const RNAK_UPDATE = \"UPDATE\";export const TOPLIST_UPDATE = \"UPDATE\"; 绑定及监听在app.wepy文件中，添加下面代码：123import &#123; setStore &#125; from 'wepy-redux'import store from './store'setStore(store) setStore()是用来将仓库中的数据绑定到页面中 类似react-redux中的 &lt;Provider store={store}&gt;&lt;/Provider&gt;组件","categories":[],"tags":[{"name":"react","slug":"react","permalink":"http://yoursite.com/tags/react/"},{"name":"redux","slug":"redux","permalink":"http://yoursite.com/tags/redux/"}]},{"title":"react-component-父子通讯","slug":"react-component-父子通讯","date":"2019-01-16T10:13:12.000Z","updated":"2019-01-16T12:53:52.914Z","comments":true,"path":"2019/01/16/react-component-父子通讯/","link":"","permalink":"http://yoursite.com/2019/01/16/react-component-父子通讯/","excerpt":"","text":"组件通讯父子通讯父级组件调用子组件，通过props来传递参数，子组件通过this.props来接收 1234567891011121314151617181920import React from \"react\";class Children extends React.Component&#123; render()&#123; const &#123; datalist &#125; = this.props; return &lt;div&gt; &lt;/div&gt; &#125;&#125;class Parent extends React.Component&#123; render()&#123; const &#123; datalist &#125; = []; return &lt;div&gt; &lt;Children datalist=&#123;datalist&#125;&gt;&lt;/Children&gt; &lt;/div&gt; &#125;&#125; 子父通讯父级组件通过props给子组件传递一个回调函数，子级组件调用父级传递过来的回调，将参数返回1234567891011121314151617181920212223242526import React from \"react\";class Children extends React.Component&#123; componentDidMount()&#123; const &#123; getData &#125; = this.props; getData([1,2,3,4,5]) &#125; render()&#123; return &lt;div&gt; this is children &lt;/div&gt; &#125;&#125;class Parent extends React.Component&#123; getData(val)&#123; //[1,2,3,4,5] console.log(val) &#125; render()&#123; return &lt;div&gt; &lt;Children getData=&#123;this.getData&#125;&gt;&lt;/Children&gt; &lt;/div&gt; &#125;&#125; 同级通讯1npm install --save events 12345678910const EventEmitter = require('events') const EventBus = new EventEmitter()//事件订阅EventBus.on(\"message\", function (text) &#123; console.log(text) //hello world&#125;)//事件发布EventBus.emit(\"message\", 'hello world') 跨级通讯案例描述: 当前有三个组件，包裹顺序依次是： Parent &gt; Middle &gt; Children现在 Parent组件有数据要传递给 Children组件 Parent &gt; Middle &gt; Children具体方案请参考 props 传参 Parent &gt; Children具体方案如下，通context对象完成数据传递： 12345678910111213141516171819202122232425262728293031323334353637383940414243import React from \"react\";import PropTypes from \"prop-types\";// 子级class Children extends React.Component&#123; static contextTypes = &#123; propA: PropTypes.string methodA: PropTypes.func &#125; render()&#123; return &lt;div&gt; this is children: &#123;this.context.propA&#125; &lt;/div&gt; &#125;&#125;// 中间class Middle extends React.Component &#123; render () &#123; return &lt;Children /&gt; &#125;&#125;// 父级class Parent extends React.Component&#123; // 声明Context对象属性 static childContextTypes = &#123; propA: PropTypes.string, methodA: PropTypes.func &#125; // 返回Context对象，方法名是约定好的 getChildContext () &#123; return &#123; propA: 'propA', methodA: () =&gt; 'methodA' &#125; &#125; render()&#123; return &lt;div&gt; &lt;Middle/&gt; &lt;/div&gt; &#125;&#125; redux全局状态的管理库，详情请看redux指南","categories":[],"tags":[{"name":"react","slug":"react","permalink":"http://yoursite.com/tags/react/"}]},{"title":"react","slug":"react","date":"2019-01-15T15:37:25.000Z","updated":"2019-01-15T15:37:36.189Z","comments":true,"path":"2019/01/15/react/","link":"","permalink":"http://yoursite.com/2019/01/15/react/","excerpt":"","text":"","categories":[],"tags":[{"name":"react","slug":"react","permalink":"http://yoursite.com/tags/react/"}]},{"title":"测试  Holle world","slug":"测试-Holle-world","date":"2019-01-15T11:30:49.000Z","updated":"2019-01-16T00:20:07.491Z","comments":true,"path":"2019/01/15/测试-Holle-world/","link":"","permalink":"http://yoursite.com/2019/01/15/测试-Holle-world/","excerpt":"","text":"","categories":[],"tags":[{"name":"tags","slug":"tags","permalink":"http://yoursite.com/tags/tags/"}]},{"title":"Hello World","slug":"hello-world","date":"2019-01-15T11:16:02.854Z","updated":"2019-01-16T06:47:52.083Z","comments":true,"path":"2019/01/15/hello-world/","link":"","permalink":"http://yoursite.com/2019/01/15/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[{"name":"bolg","slug":"bolg","permalink":"http://yoursite.com/tags/bolg/"}]}]}